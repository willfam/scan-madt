import { Injectable, inject, NgZone } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { Observable, Subject, take, merge, finalize, fromEvent, switchMap, takeUntil, takeWhile } from 'rxjs';
import BezierEasing from './bezier-easing';
import { SMOOTH_SCROLL_OPTIONS } from './smooth-scroll.model';
import * as i0 from "@angular/core";
export class SmoothScrollManager {
    constructor() {
        this.document = inject(DOCUMENT);
        this.zone = inject(NgZone);
        // Default options
        this._defaultOptions = {
            duration: 468,
            easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            },
            ...inject(SMOOTH_SCROLL_OPTIONS, { optional: true }),
        };
        // Keeps track of the ongoing SmoothScroll functions, so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this.onGoingScrolls = new Map();
    }
    /**
     * Timing method
     */
    get now() {
        return this.document.defaultView.performance?.now?.bind(this.document.defaultView.performance) || Date.now;
    }
    /**
     * changes scroll position inside an element
     */
    scrollElement(el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    }
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    getElement(el, parent) {
        if (typeof el === 'string') {
            return (parent || this.document).querySelector(el);
        }
        return coerceElement(el);
    }
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    getScrollDestroyerRef(el) {
        if (this.onGoingScrolls.has(el)) {
            this.onGoingScrolls.get(el).next();
        }
        return this.onGoingScrolls.set(el, new Subject()).get(el);
    }
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    step(context) {
        return new Observable((subscriber) => {
            let elapsed = (this.now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            const value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            this.scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            requestAnimationFrame(() => {
                subscriber.next();
                subscriber.complete();
            });
        });
    }
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream
     */
    isReached(context, destroyed) {
        if (context.currentX === context.x && context.currentY === context.y) {
            // IMPORTANT: Destroy the stream when scroll is reached ASAP!
            destroyed.next();
            return true;
        }
        return false;
    }
    /**
     * Scroll recursively until coordinates are reached
     * @param context
     * @param destroyed
     */
    scrolling(context, destroyed) {
        return this.step(context).pipe(
        // Continue while target coordinates hasn't reached yet
        takeWhile(() => !this.isReached(context, destroyed)), switchMap(() => this.scrolling(context, destroyed)));
    }
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    onScrollReached(el, resolve, destroyed) {
        destroyed.complete();
        this.onGoingScrolls.delete(el);
        this.zone.run(() => resolve());
    }
    /**
     * Terminates an ongoing smooth scroll
     */
    interrupted(el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    }
    applyScrollToOptions(el, options) {
        if (!options.duration) {
            this.scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            this.zone.runOutsideAngular(() => {
                // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
                const destroyed = this.getScrollDestroyerRef(el);
                const context = {
                    scrollable: el,
                    startTime: this.now(),
                    startX: el.scrollLeft,
                    startY: el.scrollTop,
                    x: options.left == null ? el.scrollLeft : ~~options.left,
                    y: options.top == null ? el.scrollTop : ~~options.top,
                    duration: options.duration,
                    easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
                };
                this.scrolling(context, destroyed).pipe(
                // Continue until interrupted by another scroll (new smooth scroll / wheel / touchmove)
                takeUntil(this.interrupted(el, destroyed)), 
                // Once finished, clean up the destroyer stream and resolve the promise
                finalize(() => this.onScrollReached(el, resolve, destroyed))).subscribe();
            });
        });
    }
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param customOptions specified the offsets to scroll to.
     */
    scrollTo(scrollable, customOptions) {
        const el = this.getElement(scrollable);
        const isRtl = getComputedStyle(el).direction === 'rtl';
        const options = {
            ...this._defaultOptions,
            ...customOptions,
            ...{
                // Rewrite start & end offsets as right or left offsets.
                left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,
                right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right
            }
        };
        // Rewrite the bottom offset as a top offset.
        if (options.bottom != null) {
            options.top = el.scrollHeight - el.clientHeight - options.bottom;
        }
        // Rewrite the right offset as a left offset.
        if (isRtl) {
            if (options.left != null) {
                options.right = el.scrollWidth - el.clientWidth - options.left;
            }
            options.left = options.right ? -options.right : options.right;
        }
        else {
            if (options.right != null) {
                options.left = el.scrollWidth - el.clientWidth - options.right;
            }
        }
        return this.applyScrollToOptions(el, options);
    }
    /**
     * Scroll to element by reference or selector
     */
    scrollToElement(scrollable, target, customOptions = {}) {
        const scrollableEl = this.getElement(scrollable);
        const targetEl = this.getElement(target, scrollableEl);
        if (targetEl && scrollableEl) {
            const scrollableRect = scrollableEl.getBoundingClientRect();
            const targetRect = targetEl.getBoundingClientRect();
            const options = {
                ...customOptions,
                left: targetRect.left + scrollableEl.scrollLeft - scrollableRect.left + (customOptions.left || 0),
                top: targetRect.top + scrollableEl.scrollTop - scrollableRect.top + (customOptions.top || 0)
            };
            return this.scrollTo(scrollableEl, options);
        }
        return Promise.resolve();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: SmoothScrollManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: SmoothScrollManager, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: SmoothScrollManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXNjcm9sbGJhci9zbW9vdGgtc2Nyb2xsL3NyYy9zbW9vdGgtc2Nyb2xsLW1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQWMsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFdEQsT0FBTyxFQUNMLFVBQVUsRUFFVixPQUFPLEVBQ1AsSUFBSSxFQUNKLEtBQUssRUFDTCxRQUFRLEVBQ1IsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNWLE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxZQUFZLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUNMLHFCQUFxQixFQUt0QixNQUFNLHVCQUF1QixDQUFDOztBQUsvQixNQUFNLE9BQU8sbUJBQW1CO0lBSGhDO1FBS1UsYUFBUSxHQUFhLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUV0QyxTQUFJLEdBQVcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXRDLGtCQUFrQjtRQUNELG9CQUFlLEdBQTBCO1lBQ3hELFFBQVEsRUFBRSxHQUFHO1lBQ2IsTUFBTSxFQUFFO2dCQUNOLEVBQUUsRUFBRSxJQUFJO2dCQUNSLEVBQUUsRUFBRSxDQUFDO2dCQUNMLEVBQUUsRUFBRSxJQUFJO2dCQUNSLEVBQUUsRUFBRSxDQUFDO2FBQ047WUFDRCxHQUFHLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUNyRCxDQUFDO1FBRUYsb0dBQW9HO1FBQ3BHLG1HQUFtRztRQUNuRyxvR0FBb0c7UUFDcEcscURBQXFEO1FBQzdDLG1CQUFjLEdBQWdDLElBQUksR0FBRyxFQUEwQixDQUFDO0tBMk16RjtJQXpNQzs7T0FFRztJQUNILElBQVksR0FBRztRQUNiLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUM3RyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxhQUFhLENBQUMsRUFBVyxFQUFFLENBQVMsRUFBRSxDQUFTO1FBQ3JELEVBQUUsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ2xCLEVBQUUsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7T0FFRztJQUNLLFVBQVUsQ0FBQyxFQUFpQyxFQUFFLE1BQWdCO1FBQ3BFLElBQUksT0FBTyxFQUFFLEtBQUssUUFBUSxFQUFFLENBQUM7WUFDM0IsT0FBTyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3JELENBQUM7UUFDRCxPQUFPLGFBQWEsQ0FBVSxFQUFFLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxxQkFBcUIsQ0FBQyxFQUFXO1FBQ3ZDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUNoQyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNyQyxDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxPQUFPLEVBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQ7O09BRUc7SUFDSyxJQUFJLENBQUMsT0FBeUI7UUFDcEMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxDQUFDLFVBQTRCLEVBQUUsRUFBRTtZQUNyRCxJQUFJLE9BQU8sR0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztZQUUxRSxzQ0FBc0M7WUFDdEMsT0FBTyxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO1lBRXBDLCtCQUErQjtZQUMvQixNQUFNLEtBQUssR0FBVyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRTlDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQztZQUN6RSxPQUFPLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUM7WUFFekUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzNFLHNCQUFzQjtZQUN0QixxQkFBcUIsQ0FBQyxHQUFHLEVBQUU7Z0JBQ3pCLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDbEIsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3hCLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxTQUFTLENBQUMsT0FBeUIsRUFBRSxTQUF3QjtRQUNuRSxJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssT0FBTyxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsUUFBUSxLQUFLLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNyRSw2REFBNkQ7WUFDN0QsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ2pCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxTQUFTLENBQUMsT0FBeUIsRUFBRSxTQUF3QjtRQUMzRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSTtRQUM1Qix1REFBdUQ7UUFDdkQsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFDcEQsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQ3BELENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7SUFDSyxlQUFlLENBQUMsRUFBVyxFQUFFLE9BQW1CLEVBQUUsU0FBd0I7UUFDaEYsU0FBUyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOztPQUVHO0lBQ0ssV0FBVyxDQUFDLEVBQVcsRUFBRSxTQUF3QjtRQUN2RCxPQUFPLEtBQUssQ0FDVixTQUFTLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQ3hELFNBQVMsQ0FBQyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFDNUQsU0FBUyxDQUNWLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xCLENBQUM7SUFFTyxvQkFBb0IsQ0FBQyxFQUFXLEVBQUUsT0FBOEI7UUFDdEUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN0QixJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNsRCxPQUFPLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMzQixDQUFDO1FBRUQsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO1lBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFO2dCQUMvQiwwRkFBMEY7Z0JBQzFGLE1BQU0sU0FBUyxHQUFrQixJQUFJLENBQUMscUJBQXFCLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBRWhFLE1BQU0sT0FBTyxHQUFxQjtvQkFDaEMsVUFBVSxFQUFFLEVBQUU7b0JBQ2QsU0FBUyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUU7b0JBQ3JCLE1BQU0sRUFBRSxFQUFFLENBQUMsVUFBVTtvQkFDckIsTUFBTSxFQUFFLEVBQUUsQ0FBQyxTQUFTO29CQUNwQixDQUFDLEVBQUUsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSTtvQkFDeEQsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUc7b0JBQ3JELFFBQVEsRUFBRSxPQUFPLENBQUMsUUFBUTtvQkFDMUIsTUFBTSxFQUFFLFlBQVksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztpQkFDakcsQ0FBQztnQkFFRixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxJQUFJO2dCQUNyQyx1RkFBdUY7Z0JBQ3ZGLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDMUMsdUVBQXVFO2dCQUN2RSxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQzdELENBQUMsU0FBUyxFQUFFLENBQUM7WUFDaEIsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILFFBQVEsQ0FBQyxVQUErQixFQUFFLGFBQW9DO1FBQzVFLE1BQU0sRUFBRSxHQUFZLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDaEQsTUFBTSxLQUFLLEdBQVksZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxLQUFLLEtBQUssQ0FBQztRQUVoRSxNQUFNLE9BQU8sR0FBMEI7WUFDckMsR0FBSSxJQUFJLENBQUMsZUFBb0M7WUFDN0MsR0FBRyxhQUFhO1lBQ2hCLEdBQUk7Z0JBQ0Ysd0RBQXdEO2dCQUN4RCxJQUFJLEVBQUUsYUFBYSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxJQUFJO2dCQUN6RyxLQUFLLEVBQUUsYUFBYSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxLQUFLO2FBQ3hGO1NBQ3ZCLENBQUM7UUFFRiw2Q0FBNkM7UUFDN0MsSUFBSSxPQUFPLENBQUMsTUFBTSxJQUFJLElBQUksRUFBRSxDQUFDO1lBQzNCLE9BQU8sQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7UUFDbkUsQ0FBQztRQUVELDZDQUE2QztRQUM3QyxJQUFJLEtBQUssRUFBRSxDQUFDO1lBQ1YsSUFBSSxPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksRUFBRSxDQUFDO2dCQUN6QixPQUFPLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQ2pFLENBQUM7WUFDRCxPQUFPLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztRQUNoRSxDQUFDO2FBQU0sQ0FBQztZQUNOLElBQUksT0FBTyxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUUsQ0FBQztnQkFDMUIsT0FBTyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztZQUNqRSxDQUFDO1FBQ0gsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxlQUFlLENBQUMsVUFBK0IsRUFBRSxNQUEyQixFQUFFLGdCQUE4QyxFQUFFO1FBQzVILE1BQU0sWUFBWSxHQUFZLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDMUQsTUFBTSxRQUFRLEdBQVksSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFFaEUsSUFBSSxRQUFRLElBQUksWUFBWSxFQUFFLENBQUM7WUFDN0IsTUFBTSxjQUFjLEdBQVksWUFBWSxDQUFDLHFCQUFxQixFQUFFLENBQUM7WUFDckUsTUFBTSxVQUFVLEdBQVksUUFBUSxDQUFDLHFCQUFxQixFQUFFLENBQUM7WUFFN0QsTUFBTSxPQUFPLEdBQTBCO2dCQUNyQyxHQUFHLGFBQWE7Z0JBQ2hCLElBQUksRUFBRSxVQUFVLENBQUMsSUFBSSxHQUFHLFlBQVksQ0FBQyxVQUFVLEdBQUcsY0FBYyxDQUFDLElBQUksR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO2dCQUNqRyxHQUFHLEVBQUUsVUFBVSxDQUFDLEdBQUcsR0FBRyxZQUFZLENBQUMsU0FBUyxHQUFHLGNBQWMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQzthQUM3RixDQUFDO1lBRUYsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztRQUM5QyxDQUFDO1FBRUQsT0FBTyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDM0IsQ0FBQzs4R0FoT1UsbUJBQW1CO2tIQUFuQixtQkFBbUIsY0FGbEIsTUFBTTs7MkZBRVAsbUJBQW1CO2tCQUgvQixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIGluamVjdCwgRWxlbWVudFJlZiwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgY29lcmNlRWxlbWVudCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XHJcbmltcG9ydCB7IF9XaXRob3V0LCBfWUF4aXMgfSBmcm9tICdAYW5ndWxhci9jZGsvc2Nyb2xsaW5nJztcclxuaW1wb3J0IHtcclxuICBPYnNlcnZhYmxlLFxyXG4gIFN1YnNjcmliZXIsXHJcbiAgU3ViamVjdCxcclxuICB0YWtlLFxyXG4gIG1lcmdlLFxyXG4gIGZpbmFsaXplLFxyXG4gIGZyb21FdmVudCxcclxuICBzd2l0Y2hNYXAsXHJcbiAgdGFrZVVudGlsLFxyXG4gIHRha2VXaGlsZVxyXG59IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgQmV6aWVyRWFzaW5nIGZyb20gJy4vYmV6aWVyLWVhc2luZyc7XHJcbmltcG9ydCB7XHJcbiAgU01PT1RIX1NDUk9MTF9PUFRJT05TLFxyXG4gIFNtb290aFNjcm9sbEVsZW1lbnQsXHJcbiAgU21vb3RoU2Nyb2xsU3RlcCxcclxuICBTbW9vdGhTY3JvbGxUb0VsZW1lbnRPcHRpb25zLFxyXG4gIFNtb290aFNjcm9sbFRvT3B0aW9uc1xyXG59IGZyb20gJy4vc21vb3RoLXNjcm9sbC5tb2RlbCc7XHJcblxyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTbW9vdGhTY3JvbGxNYW5hZ2VyIHtcclxuXHJcbiAgcHJpdmF0ZSBkb2N1bWVudDogRG9jdW1lbnQgPSBpbmplY3QoRE9DVU1FTlQpO1xyXG5cclxuICBwcml2YXRlIHpvbmU6IE5nWm9uZSA9IGluamVjdChOZ1pvbmUpO1xyXG5cclxuICAvLyBEZWZhdWx0IG9wdGlvbnNcclxuICBwcml2YXRlIHJlYWRvbmx5IF9kZWZhdWx0T3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zID0ge1xyXG4gICAgZHVyYXRpb246IDQ2OCxcclxuICAgIGVhc2luZzoge1xyXG4gICAgICB4MTogMC40MixcclxuICAgICAgeTE6IDAsXHJcbiAgICAgIHgyOiAwLjU4LFxyXG4gICAgICB5MjogMVxyXG4gICAgfSxcclxuICAgIC4uLmluamVjdChTTU9PVEhfU0NST0xMX09QVElPTlMsIHsgb3B0aW9uYWw6IHRydWUgfSksXHJcbiAgfTtcclxuXHJcbiAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIG9uZ29pbmcgU21vb3RoU2Nyb2xsIGZ1bmN0aW9ucywgc28gdGhleSBjYW4gYmUgaGFuZGxlZCBpbiBjYXNlIG9mIGR1cGxpY2F0aW9uLlxyXG4gIC8vIEVhY2ggc2Nyb2xsZWQgZWxlbWVudCBnZXRzIGEgZGVzdHJveWVyIHN0cmVhbSB3aGljaCBnZXRzIGRlbGV0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgY29tcGxldGVzLlxyXG4gIC8vIFB1cnBvc2U6IElmIHVzZXIgY2FsbGVkIGEgc2Nyb2xsIGZ1bmN0aW9uIGFnYWluIG9uIHRoZSBzYW1lIGVsZW1lbnQgYmVmb3JlIHRoZSBzY3JvbGxzIGNvbXBsZXRlcyxcclxuICAvLyBpdCBjYW5jZWxzIHRoZSBvbmdvaW5nIHNjcm9sbCBhbmQgc3RhcnRzIGEgbmV3IG9uZVxyXG4gIHByaXZhdGUgb25Hb2luZ1Njcm9sbHM6IE1hcDxFbGVtZW50LCBTdWJqZWN0PHZvaWQ+PiA9IG5ldyBNYXA8RWxlbWVudCwgU3ViamVjdDx2b2lkPj4oKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGltaW5nIG1ldGhvZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0IG5vdygpOiAoKSA9PiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXcucGVyZm9ybWFuY2U/Lm5vdz8uYmluZCh0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3LnBlcmZvcm1hbmNlKSB8fCBEYXRlLm5vdztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzY3JvbGxFbGVtZW50KGVsOiBFbGVtZW50LCB4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQge1xyXG4gICAgZWwuc2Nyb2xsTGVmdCA9IHg7XHJcbiAgICBlbC5zY3JvbGxUb3AgPSB5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBhIGdpdmVuIHBhcmFtZXRlciBvZiB0eXBlIEhUTUxFbGVtZW50LCBFbGVtZW50UmVmIG9yIHNlbGVjdG9yXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRFbGVtZW50KGVsOiBFbGVtZW50IHwgRWxlbWVudFJlZiB8IHN0cmluZywgcGFyZW50PzogRWxlbWVudCk6IEVsZW1lbnQge1xyXG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIChwYXJlbnQgfHwgdGhpcy5kb2N1bWVudCkucXVlcnlTZWxlY3RvcihlbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29lcmNlRWxlbWVudDxFbGVtZW50PihlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplcyBhIGRlc3Ryb3llciBzdHJlYW0sIHJlLWluaXRpYWxpemVzIGl0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgc2Nyb2xsZWRcclxuICAgKi9cclxuICBwcml2YXRlIGdldFNjcm9sbERlc3Ryb3llclJlZihlbDogRWxlbWVudCk6IFN1YmplY3Q8dm9pZD4ge1xyXG4gICAgaWYgKHRoaXMub25Hb2luZ1Njcm9sbHMuaGFzKGVsKSkge1xyXG4gICAgICB0aGlzLm9uR29pbmdTY3JvbGxzLmdldChlbCkubmV4dCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMub25Hb2luZ1Njcm9sbHMuc2V0KGVsLCBuZXcgU3ViamVjdDx2b2lkPigpKS5nZXQoZWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBmdW5jdGlvbiBjYWxsZWQgcmVjdXJzaXZlbHkgdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xyXG4gICAqL1xyXG4gIHByaXZhdGUgc3RlcChjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwKTogT2JzZXJ2YWJsZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8dm9pZD4pID0+IHtcclxuICAgICAgbGV0IGVsYXBzZWQ6IG51bWJlciA9ICh0aGlzLm5vdygpIC0gY29udGV4dC5zdGFydFRpbWUpIC8gY29udGV4dC5kdXJhdGlvbjtcclxuXHJcbiAgICAgIC8vIGF2b2lkIGVsYXBzZWQgdGltZXMgaGlnaGVyIHRoYW4gb25lXHJcbiAgICAgIGVsYXBzZWQgPSBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xyXG5cclxuICAgICAgLy8gYXBwbHkgZWFzaW5nIHRvIGVsYXBzZWQgdGltZVxyXG4gICAgICBjb25zdCB2YWx1ZTogbnVtYmVyID0gY29udGV4dC5lYXNpbmcoZWxhcHNlZCk7XHJcblxyXG4gICAgICBjb250ZXh0LmN1cnJlbnRYID0gY29udGV4dC5zdGFydFggKyAoY29udGV4dC54IC0gY29udGV4dC5zdGFydFgpICogdmFsdWU7XHJcbiAgICAgIGNvbnRleHQuY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcclxuXHJcbiAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudChjb250ZXh0LnNjcm9sbGFibGUsIGNvbnRleHQuY3VycmVudFgsIGNvbnRleHQuY3VycmVudFkpO1xyXG4gICAgICAvLyBQcm9jZWVkIHRvIHRoZSBzdGVwXHJcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KCk7XHJcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHNtb290aCBzY3JvbGwgaGFzIHJlYWNoZWQsIGNsZWFucyB1cCB0aGUgc21vb3RoIHNjcm9sbCBzdHJlYW1cclxuICAgKi9cclxuICBwcml2YXRlIGlzUmVhY2hlZChjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwLCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4pOiBib29sZWFuIHtcclxuICAgIGlmIChjb250ZXh0LmN1cnJlbnRYID09PSBjb250ZXh0LnggJiYgY29udGV4dC5jdXJyZW50WSA9PT0gY29udGV4dC55KSB7XHJcbiAgICAgIC8vIElNUE9SVEFOVDogRGVzdHJveSB0aGUgc3RyZWFtIHdoZW4gc2Nyb2xsIGlzIHJlYWNoZWQgQVNBUCFcclxuICAgICAgZGVzdHJveWVkLm5leHQoKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGwgcmVjdXJzaXZlbHkgdW50aWwgY29vcmRpbmF0ZXMgYXJlIHJlYWNoZWRcclxuICAgKiBAcGFyYW0gY29udGV4dFxyXG4gICAqIEBwYXJhbSBkZXN0cm95ZWRcclxuICAgKi9cclxuICBzY3JvbGxpbmcoY29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCwgZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+KTogT2JzZXJ2YWJsZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGVwKGNvbnRleHQpLnBpcGUoXHJcbiAgICAgIC8vIENvbnRpbnVlIHdoaWxlIHRhcmdldCBjb29yZGluYXRlcyBoYXNuJ3QgcmVhY2hlZCB5ZXRcclxuICAgICAgdGFrZVdoaWxlKCgpID0+ICF0aGlzLmlzUmVhY2hlZChjb250ZXh0LCBkZXN0cm95ZWQpKSxcclxuICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMuc2Nyb2xsaW5nKGNvbnRleHQsIGRlc3Ryb3llZCkpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVsZXRlcyB0aGUgZGVzdHJveWVyIGZ1bmN0aW9uLCBydW5zIGlmIHRoZSBzbW9vdGggc2Nyb2xsIGhhcyBmaW5pc2hlZCBvciBpbnRlcnJ1cHRlZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgb25TY3JvbGxSZWFjaGVkKGVsOiBFbGVtZW50LCByZXNvbHZlOiAoKSA9PiB2b2lkLCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4pOiB2b2lkIHtcclxuICAgIGRlc3Ryb3llZC5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5vbkdvaW5nU2Nyb2xscy5kZWxldGUoZWwpO1xyXG4gICAgdGhpcy56b25lLnJ1bigoKSA9PiByZXNvbHZlKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGVybWluYXRlcyBhbiBvbmdvaW5nIHNtb290aCBzY3JvbGxcclxuICAgKi9cclxuICBwcml2YXRlIGludGVycnVwdGVkKGVsOiBFbGVtZW50LCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4pOiBPYnNlcnZhYmxlPEV2ZW50IHwgdm9pZD4ge1xyXG4gICAgcmV0dXJuIG1lcmdlKFxyXG4gICAgICBmcm9tRXZlbnQoZWwsICd3aGVlbCcsIHsgcGFzc2l2ZTogdHJ1ZSwgY2FwdHVyZTogdHJ1ZSB9KSxcclxuICAgICAgZnJvbUV2ZW50KGVsLCAndG91Y2htb3ZlJywgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pLFxyXG4gICAgICBkZXN0cm95ZWRcclxuICAgICkucGlwZSh0YWtlKDEpKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXBwbHlTY3JvbGxUb09wdGlvbnMoZWw6IEVsZW1lbnQsIG9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKCFvcHRpb25zLmR1cmF0aW9uKSB7XHJcbiAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudChlbCwgb3B0aW9ucy5sZWZ0LCBvcHRpb25zLnRvcCk7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgICAvLyBJbml0aWFsaXplIGEgZGVzdHJveWVyIHN0cmVhbSwgcmVpbml0aWFsaXplIGl0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgc2Nyb2xsZWRcclxuICAgICAgICBjb25zdCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4gPSB0aGlzLmdldFNjcm9sbERlc3Ryb3llclJlZihlbCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXAgPSB7XHJcbiAgICAgICAgICBzY3JvbGxhYmxlOiBlbCxcclxuICAgICAgICAgIHN0YXJ0VGltZTogdGhpcy5ub3coKSxcclxuICAgICAgICAgIHN0YXJ0WDogZWwuc2Nyb2xsTGVmdCxcclxuICAgICAgICAgIHN0YXJ0WTogZWwuc2Nyb2xsVG9wLFxyXG4gICAgICAgICAgeDogb3B0aW9ucy5sZWZ0ID09IG51bGwgPyBlbC5zY3JvbGxMZWZ0IDogfn5vcHRpb25zLmxlZnQsXHJcbiAgICAgICAgICB5OiBvcHRpb25zLnRvcCA9PSBudWxsID8gZWwuc2Nyb2xsVG9wIDogfn5vcHRpb25zLnRvcCxcclxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxyXG4gICAgICAgICAgZWFzaW5nOiBCZXppZXJFYXNpbmcob3B0aW9ucy5lYXNpbmcueDEsIG9wdGlvbnMuZWFzaW5nLnkxLCBvcHRpb25zLmVhc2luZy54Miwgb3B0aW9ucy5lYXNpbmcueTIpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5zY3JvbGxpbmcoY29udGV4dCwgZGVzdHJveWVkKS5waXBlKFxyXG4gICAgICAgICAgLy8gQ29udGludWUgdW50aWwgaW50ZXJydXB0ZWQgYnkgYW5vdGhlciBzY3JvbGwgKG5ldyBzbW9vdGggc2Nyb2xsIC8gd2hlZWwgLyB0b3VjaG1vdmUpXHJcbiAgICAgICAgICB0YWtlVW50aWwodGhpcy5pbnRlcnJ1cHRlZChlbCwgZGVzdHJveWVkKSksXHJcbiAgICAgICAgICAvLyBPbmNlIGZpbmlzaGVkLCBjbGVhbiB1cCB0aGUgZGVzdHJveWVyIHN0cmVhbSBhbmQgcmVzb2x2ZSB0aGUgcHJvbWlzZVxyXG4gICAgICAgICAgZmluYWxpemUoKCkgPT4gdGhpcy5vblNjcm9sbFJlYWNoZWQoZWwsIHJlc29sdmUsIGRlc3Ryb3llZCkpLFxyXG4gICAgICAgICkuc3Vic2NyaWJlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGxzIHRvIHRoZSBzcGVjaWZpZWQgb2Zmc2V0cy4gVGhpcyBpcyBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgYnJvd3NlcidzIG5hdGl2ZSBzY3JvbGxUb1xyXG4gICAqIG1ldGhvZCwgc2luY2UgYnJvd3NlcnMgYXJlIG5vdCBjb25zaXN0ZW50IGFib3V0IHdoYXQgc2Nyb2xsTGVmdCBtZWFucyBpbiBSVEwuIEZvciB0aGlzIG1ldGhvZFxyXG4gICAqIGxlZnQgYW5kIHJpZ2h0IGFsd2F5cyByZWZlciB0byB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lciBpcnJlc3BlY3RpdmVcclxuICAgKiBvZiB0aGUgbGF5b3V0IGRpcmVjdGlvbi4gc3RhcnQgYW5kIGVuZCByZWZlciB0byBsZWZ0IGFuZCByaWdodCBpbiBhbiBMVFIgY29udGV4dCBhbmQgdmljZS12ZXJzYVxyXG4gICAqIGluIGFuIFJUTCBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzY3JvbGxhYmxlIGVsZW1lbnRcclxuICAgKiBAcGFyYW0gY3VzdG9tT3B0aW9ucyBzcGVjaWZpZWQgdGhlIG9mZnNldHMgdG8gc2Nyb2xsIHRvLlxyXG4gICAqL1xyXG4gIHNjcm9sbFRvKHNjcm9sbGFibGU6IFNtb290aFNjcm9sbEVsZW1lbnQsIGN1c3RvbU9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgZWw6IEVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoc2Nyb2xsYWJsZSk7XHJcbiAgICBjb25zdCBpc1J0bDogYm9vbGVhbiA9IGdldENvbXB1dGVkU3R5bGUoZWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XHJcblxyXG4gICAgY29uc3Qgb3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zID0ge1xyXG4gICAgICAuLi4odGhpcy5fZGVmYXVsdE9wdGlvbnMgYXMgX1dpdGhvdXQ8X1lBeGlzPiksXHJcbiAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXHJcbiAgICAgIC4uLih7XHJcbiAgICAgICAgLy8gUmV3cml0ZSBzdGFydCAmIGVuZCBvZmZzZXRzIGFzIHJpZ2h0IG9yIGxlZnQgb2Zmc2V0cy5cclxuICAgICAgICBsZWZ0OiBjdXN0b21PcHRpb25zLmxlZnQgPT0gbnVsbCA/IChpc1J0bCA/IGN1c3RvbU9wdGlvbnMuZW5kIDogY3VzdG9tT3B0aW9ucy5zdGFydCkgOiBjdXN0b21PcHRpb25zLmxlZnQsXHJcbiAgICAgICAgcmlnaHQ6IGN1c3RvbU9wdGlvbnMucmlnaHQgPT0gbnVsbCA/IChpc1J0bCA/IGN1c3RvbU9wdGlvbnMuc3RhcnQgOiBjdXN0b21PcHRpb25zLmVuZCkgOiBjdXN0b21PcHRpb25zLnJpZ2h0XHJcbiAgICAgIH0gYXMgX1dpdGhvdXQ8X1lBeGlzPilcclxuICAgIH07XHJcblxyXG4gICAgLy8gUmV3cml0ZSB0aGUgYm90dG9tIG9mZnNldCBhcyBhIHRvcCBvZmZzZXQuXHJcbiAgICBpZiAob3B0aW9ucy5ib3R0b20gIT0gbnVsbCkge1xyXG4gICAgICBvcHRpb25zLnRvcCA9IGVsLnNjcm9sbEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCAtIG9wdGlvbnMuYm90dG9tO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJld3JpdGUgdGhlIHJpZ2h0IG9mZnNldCBhcyBhIGxlZnQgb2Zmc2V0LlxyXG4gICAgaWYgKGlzUnRsKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLmxlZnQgIT0gbnVsbCkge1xyXG4gICAgICAgIG9wdGlvbnMucmlnaHQgPSBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoIC0gb3B0aW9ucy5sZWZ0O1xyXG4gICAgICB9XHJcbiAgICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMucmlnaHQgPyAtb3B0aW9ucy5yaWdodCA6IG9wdGlvbnMucmlnaHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAob3B0aW9ucy5yaWdodCAhPSBudWxsKSB7XHJcbiAgICAgICAgb3B0aW9ucy5sZWZ0ID0gZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIG9wdGlvbnMucmlnaHQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmFwcGx5U2Nyb2xsVG9PcHRpb25zKGVsLCBvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbCB0byBlbGVtZW50IGJ5IHJlZmVyZW5jZSBvciBzZWxlY3RvclxyXG4gICAqL1xyXG4gIHNjcm9sbFRvRWxlbWVudChzY3JvbGxhYmxlOiBTbW9vdGhTY3JvbGxFbGVtZW50LCB0YXJnZXQ6IFNtb290aFNjcm9sbEVsZW1lbnQsIGN1c3RvbU9wdGlvbnM6IFNtb290aFNjcm9sbFRvRWxlbWVudE9wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3Qgc2Nyb2xsYWJsZUVsOiBFbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KHNjcm9sbGFibGUpO1xyXG4gICAgY29uc3QgdGFyZ2V0RWw6IEVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQodGFyZ2V0LCBzY3JvbGxhYmxlRWwpO1xyXG5cclxuICAgIGlmICh0YXJnZXRFbCAmJiBzY3JvbGxhYmxlRWwpIHtcclxuICAgICAgY29uc3Qgc2Nyb2xsYWJsZVJlY3Q6IERPTVJlY3QgPSBzY3JvbGxhYmxlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgIGNvbnN0IHRhcmdldFJlY3Q6IERPTVJlY3QgPSB0YXJnZXRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgIGNvbnN0IG9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyA9IHtcclxuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxyXG4gICAgICAgIGxlZnQ6IHRhcmdldFJlY3QubGVmdCArIHNjcm9sbGFibGVFbC5zY3JvbGxMZWZ0IC0gc2Nyb2xsYWJsZVJlY3QubGVmdCArIChjdXN0b21PcHRpb25zLmxlZnQgfHwgMCksXHJcbiAgICAgICAgdG9wOiB0YXJnZXRSZWN0LnRvcCArIHNjcm9sbGFibGVFbC5zY3JvbGxUb3AgLSBzY3JvbGxhYmxlUmVjdC50b3AgKyAoY3VzdG9tT3B0aW9ucy50b3AgfHwgMClcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvKHNjcm9sbGFibGVFbCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gIH1cclxufVxyXG4iXX0=