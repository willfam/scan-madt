import { ContentChild, Directive, effect } from '@angular/core';
import { tap, map, delay, merge, startWith, switchMap, fromEvent, takeUntil, takeWhile, EMPTY } from 'rxjs';
import { enableSelection, preventSelection, stopPropagation } from '../utils/common';
import { ThumbAdapter } from '../thumb/thumb-adapter';
import { resizeObserver } from '../viewport';
import { PointerEventsAdapter } from '../utils/pointer-events-adapter';
import * as i0 from "@angular/core";
export class TrackAdapter extends PointerEventsAdapter {
    // Returns viewport client size
    get viewportSize() {
        return this.cmp.viewport[this.control.sizeProperty];
    }
    // Get track client rect
    get clientRect() {
        return this.nativeElement.getBoundingClientRect();
    }
    // Scrollbar track offset
    get offset() {
        return this.clientRect[this.control.clientRectProperty];
    }
    // Scrollbar track length
    get size() {
        return this.nativeElement[this.control.sizeProperty];
    }
    // Observable for track dragging events
    get pointerEvents() {
        // Observable streams for pointer events
        const pointerDown$ = fromEvent(this.nativeElement, 'pointerdown').pipe(stopPropagation(), preventSelection(this.document));
        const pointerUp$ = fromEvent(this.document, 'pointerup', { passive: true }).pipe(enableSelection(this.document));
        const pointerEnter$ = fromEvent(this.nativeElement, 'pointerover', { passive: true }).pipe(
        // When mouse is out and enters again, must set the current position first
        tap((e) => this.currMousePosition = e[this.control.offsetProperty]), map(() => true));
        const pointerLeave$ = fromEvent(this.nativeElement, 'pointerout', { passive: true }).pipe(map(() => false));
        const pointerOver$ = merge(pointerEnter$, pointerLeave$).pipe(startWith(true));
        // Keep track of current mouse location while dragging
        const pointerMove$ = fromEvent(this.nativeElement, 'pointermove', { passive: true }).pipe(tap((e) => this.currMousePosition = e[this.control.offsetProperty]));
        return pointerDown$.pipe(switchMap((startEvent) => {
            // Track pointer location while dragging
            pointerMove$.pipe(takeUntil(pointerUp$)).subscribe();
            return this.onTrackFirstClick(startEvent).pipe(delay(200), switchMap(() => {
                // Otherwise, activate pointermove and pointerout events and switch to ongoing scroll calls
                return pointerOver$.pipe(switchMap((over) => {
                    const currDirection = this.getScrollDirection(this.currMousePosition);
                    const sameDirection = this.scrollDirection === currDirection;
                    // If mouse is out the track pause the scroll calls, otherwise keep going
                    return (over && sameDirection) ? this.onTrackOngoingMousedown() : EMPTY;
                }));
            }), takeUntil(pointerUp$));
        }));
    }
    constructor() {
        effect((onCleanup) => {
            if (this.cmp.disableSensor()) {
                this.update();
                this.sizeChangeSub?.unsubscribe();
            }
            else {
                this.zone.runOutsideAngular(() => {
                    // Update styles with real track size
                    this.sizeChangeSub = resizeObserver({
                        element: this.nativeElement,
                        throttleDuration: this.cmp.sensorThrottleTime()
                    }).pipe(tap(() => this.update())).subscribe();
                });
            }
            onCleanup(() => this.sizeChangeSub?.unsubscribe());
        });
        super();
    }
    update() {
        this.cmp.nativeElement.style.setProperty(this.cssLengthProperty, `${this.size}`);
    }
    /**
     *  Callback when mouse is first clicked on the track
     */
    onTrackFirstClick(e) {
        // Initialize variables and determine scroll direction
        this.currMousePosition = e[this.control.offsetProperty];
        this.scrollDirection = this.getScrollDirection(this.currMousePosition);
        this.scrollMax = this.control.viewportScrollMax;
        return this.scrollTo(this.nextStep());
    }
    nextStep() {
        // Check which direction should the scroll go (forward or backward)
        if (this.scrollDirection === 'forward') {
            // Scroll forward
            const scrollForwardIncrement = this.getScrollForwardStep();
            // Check if the incremental position is bigger than the scroll max
            if (scrollForwardIncrement >= this.scrollMax) {
                return this.scrollMax;
            }
            return scrollForwardIncrement;
        }
        // Scroll backward
        const scrollBackwardIncrement = this.getScrollBackwardStep();
        if (scrollBackwardIncrement <= 0) {
            return 0;
        }
        return scrollBackwardIncrement;
    }
    /**
     * Callback when mouse is still down on the track
     * Incrementally scrolls towards target position until reached
     */
    onTrackOngoingMousedown() {
        const position = this.nextStep();
        return this.scrollTo(position).pipe(takeWhile(() => !this.isReached(position)), switchMap(() => this.onTrackOngoingMousedown()));
    }
    /**
     * Returns a flag that determines whether the scroll from the given position is the final step or not
     */
    isReached(position) {
        if (this.scrollDirection === 'forward') {
            return position >= this.scrollMax;
        }
        return position <= 0;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: TrackAdapter, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.1.2", type: TrackAdapter, queries: [{ propertyName: "thumb", first: true, predicate: ThumbAdapter, descendants: true }], usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: TrackAdapter, decorators: [{
            type: Directive
        }], ctorParameters: () => [], propDecorators: { thumb: [{
                type: ContentChild,
                args: [ThumbAdapter]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2stYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1zY3JvbGxiYXIvc3JjL2xpYi90cmFjay90cmFjay1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBMkIsTUFBTSxlQUFlLENBQUM7QUFDekYsT0FBTyxFQUdMLEdBQUcsRUFDSCxHQUFHLEVBQ0gsS0FBSyxFQUNMLEtBQUssRUFDTCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULEtBQUssRUFDTixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDckYsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDN0MsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0saUNBQWlDLENBQUM7O0FBR3ZFLE1BQU0sT0FBZ0IsWUFBYSxTQUFRLG9CQUFvQjtJQW9CN0QsK0JBQStCO0lBQy9CLElBQWMsWUFBWTtRQUN4QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVELHdCQUF3QjtJQUN4QixJQUFjLFVBQVU7UUFDdEIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFDcEQsQ0FBQztJQVdELHlCQUF5QjtJQUN6QixJQUFJLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFRCx5QkFB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Qyx1QkFBdUIsRUFBRSxDQUFDLENBQ2hELENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7SUFDSyxTQUFTLENBQUMsUUFBZ0I7UUFDaEMsSUFBSSxJQUFJLENBQUMsZUFBZSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ3ZDLE9BQU8sUUFBUSxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDcEMsQ0FBQztRQUNELE9BQU8sUUFBUSxJQUFJLENBQUMsQ0FBQztJQUN2QixDQUFDOzhHQXpMbUIsWUFBWTtrR0FBWixZQUFZLDZEQXFHbEIsWUFBWTs7MkZBckdOLFlBQVk7a0JBRGpDLFNBQVM7d0RBc0c4QixLQUFLO3NCQUExQyxZQUFZO3VCQUFDLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb250ZW50Q2hpbGQsIERpcmVjdGl2ZSwgZWZmZWN0LCBFZmZlY3RDbGVhbnVwUmVnaXN0ZXJGbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gIE9ic2VydmFibGUsXHJcbiAgU3Vic2NyaXB0aW9uLFxyXG4gIHRhcCxcclxuICBtYXAsXHJcbiAgZGVsYXksXHJcbiAgbWVyZ2UsXHJcbiAgc3RhcnRXaXRoLFxyXG4gIHN3aXRjaE1hcCxcclxuICBmcm9tRXZlbnQsXHJcbiAgdGFrZVVudGlsLFxyXG4gIHRha2VXaGlsZSxcclxuICBFTVBUWVxyXG59IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBlbmFibGVTZWxlY3Rpb24sIHByZXZlbnRTZWxlY3Rpb24sIHN0b3BQcm9wYWdhdGlvbiB9IGZyb20gJy4uL3V0aWxzL2NvbW1vbic7XHJcbmltcG9ydCB7IFRodW1iQWRhcHRlciB9IGZyb20gJy4uL3RodW1iL3RodW1iLWFkYXB0ZXInO1xyXG5pbXBvcnQgeyByZXNpemVPYnNlcnZlciB9IGZyb20gJy4uL3ZpZXdwb3J0JztcclxuaW1wb3J0IHsgUG9pbnRlckV2ZW50c0FkYXB0ZXIgfSBmcm9tICcuLi91dGlscy9wb2ludGVyLWV2ZW50cy1hZGFwdGVyJztcclxuXHJcbkBEaXJlY3RpdmUoKVxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHJhY2tBZGFwdGVyIGV4dGVuZHMgUG9pbnRlckV2ZW50c0FkYXB0ZXIge1xyXG5cclxuICAvLyBTdWJzY3JpcHRpb24gZm9yIHJlc2l6ZSBvYnNlcnZlclxyXG4gIHByaXZhdGUgc2l6ZUNoYW5nZVN1YjogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAvLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgbW91c2UgZHVyaW5nIHRyYWNrIGRyYWdnaW5nXHJcbiAgcHJpdmF0ZSBjdXJyTW91c2VQb3NpdGlvbjogbnVtYmVyO1xyXG5cclxuICAvLyBUaGUgZGlyZWN0aW9uIG9mIHNjcm9sbCB3aGVuIHRoZSB0cmFjayBhcmVhIGlzIGNsaWNrZWRcclxuICBwcm90ZWN0ZWQgc2Nyb2xsRGlyZWN0aW9uOiAnZm9yd2FyZCcgfCAnYmFja3dhcmQnO1xyXG5cclxuICAvLyBUaGUgbWF4aW11bSBzY3JvbGwgcG9zaXRpb24gdW50aWwgdGhlIGVuZCBpcyByZWFjaGVkXHJcbiAgcHJvdGVjdGVkIHNjcm9sbE1heDogbnVtYmVyO1xyXG5cclxuICAvLyBUaGUgQ1NTIHZhcmlhYmxlIG5hbWUgdXNlZCB0byBzZXQgdGhlIGxlbmd0aCB2YWx1ZVxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZWFkb25seSBjc3NMZW5ndGhQcm9wZXJ0eTogc3RyaW5nO1xyXG5cclxuICAvLyBSZXR1cm5zIHZpZXdwb3J0IHNjcm9sbCBzaXplXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldCB2aWV3cG9ydFNjcm9sbFNpemUoKTogbnVtYmVyO1xyXG5cclxuICAvLyBSZXR1cm5zIHZpZXdwb3J0IGNsaWVudCBzaXplXHJcbiAgcHJvdGVjdGVkIGdldCB2aWV3cG9ydFNpemUoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNtcC52aWV3cG9ydFt0aGlzLmNvbnRyb2wuc2l6ZVByb3BlcnR5XTtcclxuICB9XHJcblxyXG4gIC8vIEdldCB0cmFjayBjbGllbnQgcmVjdFxyXG4gIHByb3RlY3RlZCBnZXQgY2xpZW50UmVjdCgpOiBET01SZWN0IHtcclxuICAgIHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm5zIHRoZSBzY3JvbGwgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHRyYWNrXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldEN1cnJQb3NpdGlvbigpOiBudW1iZXI7XHJcblxyXG4gIC8vIFJldHVybnMgdGhlIGRyYWdnaW5nIGRpcmVjdGlvbiBmb3J3YXJkIG9yIGJhY2t3YXJkXHJcbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldFNjcm9sbERpcmVjdGlvbihwb3NpdGlvbjogbnVtYmVyKTogJ2ZvcndhcmQnIHwgJ2JhY2t3YXJkJztcclxuXHJcbiAgLy8gRnVuY3Rpb24gdGhhdCBzY3JvbGxzIHRvIHRoZSBnaXZlbiBwb3NpdGlvblxyXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzY3JvbGxUbyhwb3NpdGlvbjogbnVtYmVyKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxuXHJcbiAgLy8gU2Nyb2xsYmFyIHRyYWNrIG9mZnNldFxyXG4gIGdldCBvZmZzZXQoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLmNsaWVudFJlY3RbdGhpcy5jb250cm9sLmNsaWVudFJlY3RQcm9wZXJ0eV07XHJcbiAgfVxyXG5cclxuICAvLyBTY3JvbGxiYXIgdHJhY2sgbGVuZ3RoXHJcbiAgZ2V0IHNpemUoKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLm5hdGl2ZUVsZW1lbnRbdGhpcy5jb250cm9sLnNpemVQcm9wZXJ0eV07XHJcbiAgfVxyXG5cclxuICAvLyBPYnNlcnZhYmxlIGZvciB0cmFjayBkcmFnZ2luZyBldmVudHNcclxuICBnZXQgcG9pbnRlckV2ZW50cygpOiBPYnNlcnZhYmxlPFBvaW50ZXJFdmVudD4ge1xyXG4gICAgLy8gT2JzZXJ2YWJsZSBzdHJlYW1zIGZvciBwb2ludGVyIGV2ZW50c1xyXG4gICAgY29uc3QgcG9pbnRlckRvd24kOiBPYnNlcnZhYmxlPFBvaW50ZXJFdmVudD4gPSBmcm9tRXZlbnQ8UG9pbnRlckV2ZW50Pih0aGlzLm5hdGl2ZUVsZW1lbnQsICdwb2ludGVyZG93bicpLnBpcGUoXHJcbiAgICAgIHN0b3BQcm9wYWdhdGlvbigpLFxyXG4gICAgICBwcmV2ZW50U2VsZWN0aW9uKHRoaXMuZG9jdW1lbnQpXHJcbiAgICApO1xyXG4gICAgY29uc3QgcG9pbnRlclVwJDogT2JzZXJ2YWJsZTxQb2ludGVyRXZlbnQ+ID0gZnJvbUV2ZW50PFBvaW50ZXJFdmVudD4odGhpcy5kb2N1bWVudCwgJ3BvaW50ZXJ1cCcsIHsgcGFzc2l2ZTogdHJ1ZSB9KS5waXBlKFxyXG4gICAgICBlbmFibGVTZWxlY3Rpb24odGhpcy5kb2N1bWVudClcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgcG9pbnRlckVudGVyJDogT2JzZXJ2YWJsZTxib29sZWFuPiA9IGZyb21FdmVudDxQb2ludGVyRXZlbnQ+KHRoaXMubmF0aXZlRWxlbWVudCwgJ3BvaW50ZXJvdmVyJywgeyBwYXNzaXZlOiB0cnVlIH0pLnBpcGUoXHJcbiAgICAgIC8vIFdoZW4gbW91c2UgaXMgb3V0IGFuZCBlbnRlcnMgYWdhaW4sIG11c3Qgc2V0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGZpcnN0XHJcbiAgICAgIHRhcCgoZTogUG9pbnRlckV2ZW50KSA9PiB0aGlzLmN1cnJNb3VzZVBvc2l0aW9uID0gZVt0aGlzLmNvbnRyb2wub2Zmc2V0UHJvcGVydHldKSxcclxuICAgICAgbWFwKCgpID0+IHRydWUpXHJcbiAgICApO1xyXG4gICAgY29uc3QgcG9pbnRlckxlYXZlJDogT2JzZXJ2YWJsZTxib29sZWFuPiA9IGZyb21FdmVudDxQb2ludGVyRXZlbnQ+KHRoaXMubmF0aXZlRWxlbWVudCwgJ3BvaW50ZXJvdXQnLCB7IHBhc3NpdmU6IHRydWUgfSkucGlwZShcclxuICAgICAgbWFwKCgpID0+IGZhbHNlKVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBwb2ludGVyT3ZlciQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSBtZXJnZShwb2ludGVyRW50ZXIkLCBwb2ludGVyTGVhdmUkKS5waXBlKHN0YXJ0V2l0aCh0cnVlKSk7XHJcblxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiBjdXJyZW50IG1vdXNlIGxvY2F0aW9uIHdoaWxlIGRyYWdnaW5nXHJcbiAgICBjb25zdCBwb2ludGVyTW92ZSQ6IE9ic2VydmFibGU8UG9pbnRlckV2ZW50PiA9IGZyb21FdmVudDxQb2ludGVyRXZlbnQ+KHRoaXMubmF0aXZlRWxlbWVudCwgJ3BvaW50ZXJtb3ZlJywgeyBwYXNzaXZlOiB0cnVlIH0pLnBpcGUoXHJcbiAgICAgIHRhcCgoZTogUG9pbnRlckV2ZW50KSA9PiB0aGlzLmN1cnJNb3VzZVBvc2l0aW9uID0gZVt0aGlzLmNvbnRyb2wub2Zmc2V0UHJvcGVydHldKVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gcG9pbnRlckRvd24kLnBpcGUoXHJcbiAgICAgIHN3aXRjaE1hcCgoc3RhcnRFdmVudDogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgLy8gVHJhY2sgcG9pbnRlciBsb2NhdGlvbiB3aGlsZSBkcmFnZ2luZ1xyXG4gICAgICAgIHBvaW50ZXJNb3ZlJC5waXBlKHRha2VVbnRpbChwb2ludGVyVXAkKSkuc3Vic2NyaWJlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm9uVHJhY2tGaXJzdENsaWNrKHN0YXJ0RXZlbnQpLnBpcGUoXHJcbiAgICAgICAgICBkZWxheSgyMDApLFxyXG4gICAgICAgICAgc3dpdGNoTWFwKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhY3RpdmF0ZSBwb2ludGVybW92ZSBhbmQgcG9pbnRlcm91dCBldmVudHMgYW5kIHN3aXRjaCB0byBvbmdvaW5nIHNjcm9sbCBjYWxsc1xyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRlck92ZXIkLnBpcGUoXHJcbiAgICAgICAgICAgICAgc3dpdGNoTWFwKChvdmVyOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyRGlyZWN0aW9uOiAnZm9yd2FyZCcgfCAnYmFja3dhcmQnID0gdGhpcy5nZXRTY3JvbGxEaXJlY3Rpb24odGhpcy5jdXJyTW91c2VQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1lRGlyZWN0aW9uOiBib29sZWFuID0gdGhpcy5zY3JvbGxEaXJlY3Rpb24gPT09IGN1cnJEaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBtb3VzZSBpcyBvdXQgdGhlIHRyYWNrIHBhdXNlIHRoZSBzY3JvbGwgY2FsbHMsIG90aGVyd2lzZSBrZWVwIGdvaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKG92ZXIgJiYgc2FtZURpcmVjdGlvbikgPyB0aGlzLm9uVHJhY2tPbmdvaW5nTW91c2Vkb3duKCkgOiBFTVBUWTtcclxuICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgKSBhcyBPYnNlcnZhYmxlPFBvaW50ZXJFdmVudD47XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIHRha2VVbnRpbChwb2ludGVyVXAkKSxcclxuICAgICAgICApO1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIFJlZmVyZW5jZSB0byB0aGUgVGh1bWJBZGFwdGVyIGNvbXBvbmVudFxyXG4gIEBDb250ZW50Q2hpbGQoVGh1bWJBZGFwdGVyKSBwcm90ZWN0ZWQgdGh1bWI6IFRodW1iQWRhcHRlcjtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBlZmZlY3QoKG9uQ2xlYW51cDogRWZmZWN0Q2xlYW51cFJlZ2lzdGVyRm4pID0+IHtcclxuICAgICAgaWYgKHRoaXMuY21wLmRpc2FibGVTZW5zb3IoKSkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgdGhpcy5zaXplQ2hhbmdlU3ViPy51bnN1YnNjcmliZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHdpdGggcmVhbCB0cmFjayBzaXplXHJcbiAgICAgICAgICB0aGlzLnNpemVDaGFuZ2VTdWIgPSByZXNpemVPYnNlcnZlcih7XHJcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMubmF0aXZlRWxlbWVudCxcclxuICAgICAgICAgICAgdGhyb3R0bGVEdXJhdGlvbjogdGhpcy5jbXAuc2Vuc29yVGhyb3R0bGVUaW1lKClcclxuICAgICAgICAgIH0pLnBpcGUoXHJcbiAgICAgICAgICAgIHRhcCgoKSA9PiB0aGlzLnVwZGF0ZSgpKVxyXG4gICAgICAgICAgKS5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgb25DbGVhbnVwKCgpID0+IHRoaXMuc2l6ZUNoYW5nZVN1Yj8udW5zdWJzY3JpYmUoKSk7XHJcbiAgICB9KTtcclxuICAgIHN1cGVyKCk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0U2Nyb2xsRm9yd2FyZFN0ZXAoKTogbnVtYmVyO1xyXG5cclxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0U2Nyb2xsQmFja3dhcmRTdGVwKCk6IG51bWJlcjtcclxuXHJcbiAgcHJpdmF0ZSB1cGRhdGUoKTogdm9pZCB7XHJcbiAgICB0aGlzLmNtcC5uYXRpdmVFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHRoaXMuY3NzTGVuZ3RoUHJvcGVydHksIGAkeyB0aGlzLnNpemUgfWApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogIENhbGxiYWNrIHdoZW4gbW91c2UgaXMgZmlyc3QgY2xpY2tlZCBvbiB0aGUgdHJhY2tcclxuICAgKi9cclxuICBvblRyYWNrRmlyc3RDbGljayhlOiBQb2ludGVyRXZlbnQpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcclxuICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzIGFuZCBkZXRlcm1pbmUgc2Nyb2xsIGRpcmVjdGlvblxyXG4gICAgdGhpcy5jdXJyTW91c2VQb3NpdGlvbiA9IGVbdGhpcy5jb250cm9sLm9mZnNldFByb3BlcnR5XTtcclxuICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gdGhpcy5nZXRTY3JvbGxEaXJlY3Rpb24odGhpcy5jdXJyTW91c2VQb3NpdGlvbik7XHJcbiAgICB0aGlzLnNjcm9sbE1heCA9IHRoaXMuY29udHJvbC52aWV3cG9ydFNjcm9sbE1heDtcclxuICAgIHJldHVybiB0aGlzLnNjcm9sbFRvKHRoaXMubmV4dFN0ZXAoKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG5leHRTdGVwKCk6IG51bWJlciB7XHJcbiAgICAvLyBDaGVjayB3aGljaCBkaXJlY3Rpb24gc2hvdWxkIHRoZSBzY3JvbGwgZ28gKGZvcndhcmQgb3IgYmFja3dhcmQpXHJcbiAgICBpZiAodGhpcy5zY3JvbGxEaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xyXG4gICAgICAvLyBTY3JvbGwgZm9yd2FyZFxyXG4gICAgICBjb25zdCBzY3JvbGxGb3J3YXJkSW5jcmVtZW50OiBudW1iZXIgPSB0aGlzLmdldFNjcm9sbEZvcndhcmRTdGVwKCk7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgaW5jcmVtZW50YWwgcG9zaXRpb24gaXMgYmlnZ2VyIHRoYW4gdGhlIHNjcm9sbCBtYXhcclxuICAgICAgaWYgKHNjcm9sbEZvcndhcmRJbmNyZW1lbnQgPj0gdGhpcy5zY3JvbGxNYXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxNYXg7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNjcm9sbEZvcndhcmRJbmNyZW1lbnQ7XHJcbiAgICB9XHJcbiAgICAvLyBTY3JvbGwgYmFja3dhcmRcclxuICAgIGNvbnN0IHNjcm9sbEJhY2t3YXJkSW5jcmVtZW50OiBudW1iZXIgPSB0aGlzLmdldFNjcm9sbEJhY2t3YXJkU3RlcCgpO1xyXG5cclxuICAgIGlmIChzY3JvbGxCYWNrd2FyZEluY3JlbWVudCA8PSAwKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNjcm9sbEJhY2t3YXJkSW5jcmVtZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgd2hlbiBtb3VzZSBpcyBzdGlsbCBkb3duIG9uIHRoZSB0cmFja1xyXG4gICAqIEluY3JlbWVudGFsbHkgc2Nyb2xscyB0b3dhcmRzIHRhcmdldCBwb3NpdGlvbiB1bnRpbCByZWFjaGVkXHJcbiAgICovXHJcbiAgb25UcmFja09uZ29pbmdNb3VzZWRvd24oKTogT2JzZXJ2YWJsZTx1bmtub3duPiB7XHJcbiAgICBjb25zdCBwb3NpdGlvbjogbnVtYmVyID0gdGhpcy5uZXh0U3RlcCgpO1xyXG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG8ocG9zaXRpb24pLnBpcGUoXHJcbiAgICAgIHRha2VXaGlsZSgoKSA9PiAhdGhpcy5pc1JlYWNoZWQocG9zaXRpb24pKSxcclxuICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMub25UcmFja09uZ29pbmdNb3VzZWRvd24oKSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgZmxhZyB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgc2Nyb2xsIGZyb20gdGhlIGdpdmVuIHBvc2l0aW9uIGlzIHRoZSBmaW5hbCBzdGVwIG9yIG5vdFxyXG4gICAqL1xyXG4gIHByaXZhdGUgaXNSZWFjaGVkKHBvc2l0aW9uOiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgIGlmICh0aGlzLnNjcm9sbERpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XHJcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSB0aGlzLnNjcm9sbE1heDtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbiA8PSAwO1xyXG4gIH1cclxufVxyXG4iXX0=